<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Button Folding Into Bird</title>
    <style>
        .button {
            --primary: #758A93;
            --primary-dark: #5A6B73;
            --primary-darkest: #4A565D;
            --text: #FFFFFF;
            --text-opacity: 1;
            --success: #2B3044;
            --success-scale: 0.2;
            --success-opacity: 0;
            --border-radius: 7;
            --overflow: hidden;
            --rotate: 0;
            --plane-x: 0;
            --plane-y: 0;
            --plane-opacity: 1;
            --left-wing-background: var(--primary);
            --left-wing-first-x: 0;
            --left-wing-first-y: 0;
            --left-wing-second-x: 50;
            --left-wing-second-y: 0;
            --left-wing-third-x: 0;
            --left-wing-third-y: 100;
            --left-body-background: var(--primary);
            --left-body-first-x: 50;
            --left-body-first-y: 0;
            --left-body-second-x: 50;
            --left-body-second-y: 100;
            --left-body-third-x: 0;
            --left-body-third-y: 100;
            --right-wing-background: var(--primary);
            --right-wing-first-x: 50;
            --right-wing-first-y: 0;
            --right-wing-second-x: 100;
            --right-wing-second-y: 0;
            --right-wing-third-x: 100;
            --right-wing-third-y: 100;
            --right-body-background: var(--primary);
            --right-body-first-x: 50;
            --right-body-first-y: 0;
            --right-body-second-x: 50;
            --right-body-second-y: 100;
            --right-body-third-x: 100;
            --right-body-third-y: 100;
            display: block;
            cursor: pointer;
            position: relative;
            border: 0;
            padding: 8px 0;
            min-width: 100px;
            text-align: center;
            margin: 0;
            line-height: 24px;
            font-family: inherit;
            font-weight: 500;
            font-size: 14px;
            background: none;
            outline: none;
            color: var(--text);
            transform: rotate(calc(var(--rotate) * 1deg)) translateZ(0);
            -webkit-appearance: none;
            -webkit-tap-highlight-color: transparent;
            z-index: 1;
        }

        .button .left,
        .button .right {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            opacity: var(--plane-opacity);
            transform: translate(calc(var(--plane-x) * 1px), calc(var(--plane-y) * 1px)) translateZ(0);
        }

        .button .left:before,
        .button .left:after,
        .button .right:before,
        .button .right:after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            border-radius: calc(var(--border-radius) * 1px);
            transform: translate(var(--x, 0.4%), var(--y, 0)) translateZ(0);
            z-index: var(--z-index, 2);
            background: var(--background, var(--left-wing-background));
            clip-path: polygon(
                calc(var(--first-x, var(--left-wing-first-x)) * 1%) calc(var(--first-y, var(--left-wing-first-y)) * 1%), 
                calc(var(--second-x, var(--left-wing-second-x)) * 1%) calc(var(--second-y, var(--left-wing-second-y)) * 1%), 
                calc(var(--third-x, var(--left-wing-third-x)) * 1%) calc(var(--third-y, var(--left-wing-third-y)) * 1%)
            );
        }

        .button .left:after {
            --x: 0;
            --z-index: 1;
            --background: var(--left-body-background);
            --first-x: var(--left-body-first-x);
            --first-y: var(--left-body-first-y);
            --second-x: var(--left-body-second-x);
            --second-y: var(--left-body-second-y);
            --third-x: var(--left-body-third-x);
            --third-y: var(--left-body-third-y);
        }

        .button .right:before {
            --x: -0.4%;
            --z-index: 2;
            --background: var(--right-wing-background);
            --first-x: var(--right-wing-first-x);
            --first-y: var(--right-wing-first-y);
            --second-x: var(--right-wing-second-x);
            --second-y: var(--right-wing-second-y);
            --third-x: var(--right-wing-third-x);
            --third-y: var(--right-wing-third-y);
        }

        .button .right:after {
            --x: 0;
            --z-index: 1;
            --background: var(--right-body-background);
            --first-x: var(--right-body-first-x);
            --first-y: var(--right-body-first-y);
            --second-x: var(--right-body-second-x);
            --second-y: var(--right-body-second-y);
            --third-x: var(--right-body-third-x);
            --third-y: var(--right-body-third-y);
        }

        .button span {
            display: block;
            position: relative;
            z-index: 4;
            opacity: var(--text-opacity);
        }

        .button span.success {
            z-index: 0;
            position: absolute;
            left: 0;
            right: 0;
            top: 8px;
            transform: rotate(calc(var(--rotate) * -1deg)) scale(var(--success-scale)) translateZ(0);
            opacity: var(--success-opacity);
            color: var(--success);
        }

        html {
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        * {
            box-sizing: inherit;
        }

        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Inter', Arial, sans-serif;
            background: #E1E6F9;
            position: relative;
            overflow: hidden;
        }
        
        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="three-canvas"></canvas>
    
    <button class="button">
        <span class="default">Send</span>
        <span class="success">Sent</span>
        <div class="left"></div>
        <div class="right"></div>
    </button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <script>
        // Three.js Bird Geometry
        function Bird() {
            const geometry = new THREE.BufferGeometry();
            
            const vertices = new Float32Array([
                5, 0, 0,
                -5, -2, 1,
                -5, 0, 0,
                -5, -2, -1,
                
                0, 2, -6,
                0, 2, 6
            ]);
            
            const indices = new Uint16Array([
                0, 1, 2,
                0, 2, 3,
                0, 3, 4,
                0, 4, 1
            ]);
            
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            
            return geometry;
        }

        // Boid class with physics (matching React component)
        var Boid = function() {
            var vector = new THREE.Vector3();
            var _acceleration;
            var _width = 900;
            var _height = 900;
            var _depth = 1600;
            var _goal = null;
            var _neighborhoodRadius = 800;
            var _maxSpeed = 3; // Increased speed for faster animation
            var _maxSteerForce = 0.1;
            var _avoidWalls = false;

            this.position = new THREE.Vector3();
            this.velocity = new THREE.Vector3();
            _acceleration = new THREE.Vector3();

            this.setGoal = function(target) {
                _goal = target;
            }

            this.setAvoidWalls = function(value) {
                _avoidWalls = value;
            }

            this.setWorldSize = function(width, height, depth) {
                _width = width;
                _height = height;
                _depth = depth;
            }

            this.run = function(boids) {
                if (_avoidWalls) {
                    vector.set(-_width, this.position.y, this.position.z);
                    vector = this.avoid(vector);
                    vector.multiplyScalar(19);
                    _acceleration.add(vector);

                    vector.set(_width, this.position.y, this.position.z);
                    vector = this.avoid(vector);
                    vector.multiplyScalar(19);
                    _acceleration.add(vector);

                    vector.set(this.position.x, -_height, this.position.z);
                    vector = this.avoid(vector);
                    vector.multiplyScalar(19);
                    _acceleration.add(vector);

                    vector.set(this.position.x, _height, this.position.z);
                    vector = this.avoid(vector);
                    vector.multiplyScalar(19);
                    _acceleration.add(vector);

                    vector.set(this.position.x, this.position.y, -_depth);
                    vector = this.avoid(vector);
                    vector.multiplyScalar(15);
                    _acceleration.add(vector);

                    vector.set(this.position.x, this.position.y, _depth);
                    vector = this.avoid(vector);
                    vector.multiplyScalar(5);
                    _acceleration.add(vector);
                }

                if (Math.random() > 0.5) {
                    this.flock(boids);
                }

                this.move();
            }

            this.flock = function(boids) {
                if (_goal) {
                    _acceleration.add(this.reach(_goal, 0.9));
                }

                _acceleration.add(this.alignment(boids));
                _acceleration.add(this.cohesion(boids));
                _acceleration.add(this.separation(boids));
            }

            this.move = function() {
                this.velocity.add(_acceleration);
                var l = this.velocity.length();
                if (l > _maxSpeed) {
                    this.velocity.divideScalar(l / _maxSpeed);
                }
                this.position.add(this.velocity);
                _acceleration.set(0, 0, 0);
            }

            this.checkBounds = function() {
                if (this.position.x > _width) this.position.x = -_width;
                if (this.position.x < -_width) this.position.x = _width;
                if (this.position.y > _height) this.position.y = -_height;
                if (this.position.y < -_height) this.position.y = _height;
                if (this.position.z > _depth) this.position.z = -_depth;
                if (this.position.z < -_depth) this.position.z = _depth;
            }

            this.avoid = function(target) {
                var steer = new THREE.Vector3();
                steer.copy(this.position);
                steer.sub(target);
                steer.multiplyScalar(1 / this.position.distanceToSquared(target));
                return steer;
            }

            this.repulse = function(target) {
                var distance = this.position.distanceTo(target);
                if (distance < 200) {
                    var steer = new THREE.Vector3();
                    steer.subVectors(this.position, target);
                    steer.multiplyScalar(0.9 / distance);
                    _acceleration.add(steer);
                }
            }

            this.reach = function(target, amount) {
                var steer = new THREE.Vector3();
                steer.subVectors(target, this.position);
                steer.multiplyScalar(amount);
                return steer;
            }

            this.alignment = function(boids) {
                var boid, velSum = new THREE.Vector3();
                var count = 0;

                for (var i = 0, il = boids.length; i < il; i++) {
                    if (Math.random() > 0.5) continue;

                    boid = boids[i];
                    var distance = boid.position.distanceTo(this.position);

                    if (distance > 0 && distance <= _neighborhoodRadius) {
                        velSum.add(boid.velocity);
                        count++;
                    }
                }

                if (count > 0) {
                    velSum.divideScalar(count);
                    var l = velSum.length();
                    if (l > _maxSteerForce) {
                        velSum.divideScalar(l / _maxSteerForce);
                    }
                }

                return velSum;
            }

            this.cohesion = function(boids) {
                var boid, distance;
                var posSum = new THREE.Vector3();
                var steer = new THREE.Vector3();
                var count = 0;

                for (var i = 0, il = boids.length; i < il; i++) {
                    if (Math.random() > 0.5) continue;

                    boid = boids[i];
                    distance = boid.position.distanceTo(this.position);

                    if (distance > 0 && distance <= _neighborhoodRadius) {
                        posSum.add(boid.position);
                        count++;
                    }
                }

                if (count > 0) {
                    posSum.divideScalar(count);
                }

                steer.subVectors(posSum, this.position);
                var l = steer.length();
                if (l > _maxSteerForce) {
                    steer.divideScalar(l / _maxSteerForce);
                }

                return steer;
            }

            this.separation = function(boids) {
                var boid, distance;
                var posSum = new THREE.Vector3();
                var repulse = new THREE.Vector3();

                for (var i = 0, il = boids.length; i < il; i++) {
                    if (Math.random() > 0.2) continue;

                    boid = boids[i];
                    distance = boid.position.distanceTo(this.position);

                    if (distance > 0 && distance <= _neighborhoodRadius) {
                        repulse.subVectors(this.position, boid.position);
                        repulse.normalize();
                        repulse.divideScalar(distance);
                        posSum.add(repulse);
                    }
                }

                return posSum;
            }
        }

        // Three.js setup
        let scene, camera, renderer, bird, boid;
        let threeJsActive = false;
        let waypoints = [];
        let currentWaypoint = 0;

        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(
                window.innerWidth / -2, window.innerWidth / 2,
                window.innerHeight / 2, window.innerHeight / -2,
                1, 1000
            );
            camera.position.z = 450;

            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('three-canvas'),
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);

            const birdGeometry = new Bird();
            const birdMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x758A93, 
                side: THREE.DoubleSide 
            });
            bird = new THREE.Mesh(birdGeometry, birdMaterial);
            bird.scale.set(2.5, 2.5, 2.5);
            bird.phase = 0;
            scene.add(bird);

            boid = new Boid();
        }

        function createLoopWaypoints(startX, startY) {
            const points = [];
            const numPoints = 25; // More points for smoother exit
            const loopRadius = 100;
            
            // Get viewport bounds for OrthographicCamera
            // Camera sees from -width/2 to width/2 and -height/2 to height/2
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const cameraRight = viewportWidth / 2;
            const cameraLeft = -viewportWidth / 2;
            const cameraTop = viewportHeight / 2;
            const cameraBottom = -viewportHeight / 2;
            
            console.log('Start position:', startX, startY, 'Viewport bounds:', { cameraLeft, cameraRight, cameraTop, cameraBottom });
            
            // Create path: fly UP, loop-de-loop, exit bottom right COMPLETELY off screen
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                let x, y;
                
                if (t < 0.3) {
                    // Fly UPWARD
                    const t1 = t / 0.3;
                    x = startX + t1 * 80;
                    y = startY + t1 * 200; // POSITIVE Y = UP
                } else if (t < 0.7) {
                    // Complete the loop-de-loop
                    const t2 = (t - 0.3) / 0.4;
                    const angle = t2 * Math.PI * 2;
                    const loopCenterX = startX + 150;
                    const loopCenterY = startY + 200;
                    x = loopCenterX + Math.sin(angle) * loopRadius;
                    y = loopCenterY - Math.cos(angle) * loopRadius;
                } else {
                    // Exit toward bottom right - ensure it goes COMPLETELY off screen
                    const t3 = (t - 0.7) / 0.3;
                    // Start from loop end position, fly far beyond viewport bounds
                    const exitStartX = startX + 250;
                    const exitStartY = startY + 100;
                    // Final position should be well beyond the right edge and bottom edge
                    const finalX = cameraRight + 600; // Well beyond right edge
                    const finalY = cameraBottom - 400; // Well beyond bottom edge
                    x = exitStartX + t3 * (finalX - exitStartX);
                    y = exitStartY + t3 * (finalY - exitStartY);
                }
                
                if (i < 5 || i > numPoints - 3) console.log('Waypoint', i, ':', x, y, 'offScreen:', x > cameraRight || y < cameraBottom);
                points.push(new THREE.Vector3(x, y, 0));
            }
            
            console.log('âœ… Created', points.length, 'waypoints - final waypoint:', points[points.length - 1], 'should be off screen');
            return points;
        }

        function animateThreeJS() {
            if (!threeJsActive) return;
            requestAnimationFrame(animateThreeJS);

            // Use boid physics to smoothly move toward next waypoint
            if (currentWaypoint < waypoints.length) {
                const target = waypoints[currentWaypoint];
                boid.setGoal(target);
                // Use run() method with empty boids array (single bird, no flocking)
                boid.run([]);
                
                bird.position.copy(boid.position);
                
                // Move to next waypoint when close enough
                if (boid.position.distanceTo(target) < 30) {
                    currentWaypoint++;
                }
                
                // Calculate rotation based on velocity (matching HTML reference)
                const velLength = boid.velocity.length();
                if (velLength > 0) {
                    bird.rotation.y = Math.atan2(-boid.velocity.z, boid.velocity.x);
                    bird.rotation.z = Math.asin(boid.velocity.y / velLength);
                }
                
                // Wing flapping (matching HTML reference)
                bird.phase = (bird.phase + (Math.max(0, bird.rotation.z) + 0.1)) % 62.73;
                const flapAmount = Math.sin(bird.phase) * 5;
                // Update wing vertices (indices 4 and 5 in the geometry)
                if (bird.geometry.attributes.position && bird.geometry.attributes.position.array) {
                    bird.geometry.attributes.position.array[13] = flapAmount; // vertex 4 y
                    bird.geometry.attributes.position.array[16] = flapAmount; // vertex 5 y
                    bird.geometry.attributes.position.needsUpdate = true;
                }
            } else {
                // Animation complete
                threeJsActive = false;
                const button = document.querySelector('.button');
                setTimeout(() => {
                    button.removeAttribute('style');
                    gsap.fromTo(button, {
                        opacity: 0,
                        y: -8
                    }, {
                        opacity: 1,
                        y: 0,
                        clearProps: true,
                        duration: 0.3,
                        onComplete() {
                            button.classList.remove('active');
                        }
                    });
                }, 500);
            }

            renderer.render(scene, camera);
        }

        initThreeJS();

        // Button animation - fold into BIRD shape
        document.querySelectorAll('.button').forEach(button => {
            let getVar = variable => getComputedStyle(button).getPropertyValue(variable);

            button.addEventListener('click', e => {
                if(!button.classList.contains('active')) {
                    button.classList.add('active');

                    // Get button position
                    const rect = button.getBoundingClientRect();
                    const buttonCenterX = rect.left + rect.width / 2 - window.innerWidth / 2;
                    const buttonCenterY = -(rect.top + rect.height / 2 - window.innerHeight / 2);

                    // Bird fold - matching boid structure with triangular wings
                    gsap.to(button, {
                        keyframes: [{
                            // Collapse to center
                            '--left-wing-first-x': 50,
                            '--left-wing-first-y': 50,
                            '--left-wing-second-x': 50,
                            '--left-wing-second-y': 50,
                            '--left-wing-third-x': 50,
                            '--left-wing-third-y': 50,
                            '--right-wing-first-x': 50,
                            '--right-wing-first-y': 50,
                            '--right-wing-second-x': 50,
                            '--right-wing-second-y': 50,
                            '--right-wing-third-x': 50,
                            '--right-wing-third-y': 50,
                            '--border-radius': 0,
                            duration: 0.3
                        }, {
                            // Bird shape - like boid geometry (diagonal view, nose upper-right)
                            '--rotate': 50,
                            
                            // Left wing - large triangle
                            '--left-wing-first-x': 60,   // connects to body
                            '--left-wing-first-y': 45,
                            '--left-wing-second-x': 15,  // wing tip (far left)
                            '--left-wing-second-y': 65,
                            '--left-wing-third-x': 50,   // back of body
                            '--left-wing-third-y': 55,
                            
                            // Right wing - large triangle
                            '--right-wing-first-x': 60,  // connects to body
                            '--right-wing-first-y': 45,
                            '--right-wing-second-x': 80, // wing tip (right)
                            '--right-wing-second-y': 55,
                            '--right-wing-third-x': 50,  // back of body
                            '--right-wing-third-y': 55,
                            
                            // Body - small triangle pointing upper-right (nose)
                            '--left-body-first-x': 60,
                            '--left-body-first-y': 43,
                            '--left-body-second-x': 70,  // nose tip
                            '--left-body-second-y': 40,
                            '--left-body-third-x': 60,
                            '--left-body-third-y': 47,
                            
                            '--right-body-first-x': 65,
                            '--right-body-first-y': 45,
                            '--right-body-second-x': 65,
                            '--right-body-second-y': 45,
                            '--right-body-third-x': 65,
                            '--right-body-third-y': 45,
                            
                            duration: 0.3
                        }]
                    });

                    // Wing flapping animation
                    const flapTimeline = gsap.timeline({ delay: 1.0 });
                    
                    // Flap 3 times - wings sweep up and down
                    for (let i = 0; i < 3; i++) {
                        flapTimeline.to(button, {
                            // Wings up
                            '--left-wing-second-y': 55,
                            '--right-wing-second-y': 45,
                            duration: 0.2,
                            ease: "power2.out"
                        }).to(button, {
                            // Wings down  
                            '--left-wing-second-y': 70,
                            '--right-wing-second-y': 60,
                            duration: 0.2,
                            ease: "power2.in"
                        });
                    }
                    
                    // After flapping, transition to Three.js
                    flapTimeline.to(button, {
                        '--plane-opacity': 0,
                        duration: 0.2,
                        onComplete() {
                            // Start Three.js bird with physics
                            boid.position.set(buttonCenterX, buttonCenterY, 0);
                            boid.velocity.set(0.5, -0.5, 0);
                            waypoints = createLoopWaypoints(buttonCenterX, buttonCenterY);
                            currentWaypoint = 0;
                            threeJsActive = true;
                            animateThreeJS();
                        }
                    });

                    // Color changes
                    gsap.to(button, {
                        keyframes: [{
                            '--text-opacity': 0,
                            '--left-wing-background': getVar('--primary-darkest'),
                            '--right-wing-background': getVar('--primary-darkest'),
                            duration: 0.1
                        }, {
                            '--left-wing-background': getVar('--primary'),
                            '--right-wing-background': getVar('--primary'),
                            duration: 0.1
                        }, {
                            '--left-body-background': getVar('--primary-dark'),
                            '--right-body-background': getVar('--primary-darkest'),
                            duration: 0.4
                        }, {
                            '--success-opacity': 1,
                            '--success-scale': 1,
                            duration: 0.25,
                            delay: 0.25
                        }]
                    });
                }
            });
        });

        window.addEventListener('resize', () => {
            camera.left = window.innerWidth / -2;
            camera.right = window.innerWidth / 2;
            camera.top = window.innerHeight / 2;
            camera.bottom = window.innerHeight / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

