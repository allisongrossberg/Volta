<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Button Folding Into Bird</title>
    <style>
        .button {
            --primary: #DDC57A;
            --primary-dark: #C9AE60;
            --primary-darkest: #B59748;
            --text: #FFFFFF;
            --text-opacity: 1;
            --success: #2B3044;
            --success-scale: 0.2;
            --success-opacity: 0;
            --border-radius: 7;
            --overflow: hidden;
            --rotate: 0;
            --plane-x: 0;
            --plane-y: 0;
            --plane-opacity: 1;
            --left-wing-background: var(--primary);
            --left-wing-first-x: 0;
            --left-wing-first-y: 0;
            --left-wing-second-x: 50;
            --left-wing-second-y: 0;
            --left-wing-third-x: 0;
            --left-wing-third-y: 100;
            --left-body-background: var(--primary);
            --left-body-first-x: 50;
            --left-body-first-y: 0;
            --left-body-second-x: 50;
            --left-body-second-y: 100;
            --left-body-third-x: 0;
            --left-body-third-y: 100;
            --right-wing-background: var(--primary);
            --right-wing-first-x: 50;
            --right-wing-first-y: 0;
            --right-wing-second-x: 100;
            --right-wing-second-y: 0;
            --right-wing-third-x: 100;
            --right-wing-third-y: 100;
            --right-body-background: var(--primary);
            --right-body-first-x: 50;
            --right-body-first-y: 0;
            --right-body-second-x: 50;
            --right-body-second-y: 100;
            --right-body-third-x: 100;
            --right-body-third-y: 100;
            display: block;
            cursor: pointer;
            position: relative;
            border: 0;
            padding: 8px 0;
            min-width: 100px;
            text-align: center;
            margin: 0;
            line-height: 24px;
            font-family: inherit;
            font-weight: 500;
            font-size: 14px;
            background: none;
            outline: none;
            color: var(--text);
            transform: rotate(calc(var(--rotate) * 1deg)) translateZ(0);
            -webkit-appearance: none;
            appearance: none;
            -webkit-tap-highlight-color: transparent;
            z-index: 1;
        }

        .button .left,
        .button .right {
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            opacity: var(--plane-opacity);
            transform: translate(calc(var(--plane-x) * 1px), calc(var(--plane-y) * 1px)) translateZ(0);
        }

        .button .left:before,
        .button .left:after,
        .button .right:before,
        .button .right:after {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            border-radius: calc(var(--border-radius) * 1px);
            transform: translate(var(--x, 0.4%), var(--y, 0)) translateZ(0);
            z-index: var(--z-index, 2);
            background: var(--background, var(--left-wing-background));
            clip-path: polygon(
                calc(var(--first-x, var(--left-wing-first-x)) * 1%) calc(var(--first-y, var(--left-wing-first-y)) * 1%), 
                calc(var(--second-x, var(--left-wing-second-x)) * 1%) calc(var(--second-y, var(--left-wing-second-y)) * 1%), 
                calc(var(--third-x, var(--left-wing-third-x)) * 1%) calc(var(--third-y, var(--left-wing-third-y)) * 1%)
            );
            -webkit-clip-path: polygon(
                calc(var(--first-x, var(--left-wing-first-x)) * 1%) calc(var(--first-y, var(--left-wing-first-y)) * 1%), 
                calc(var(--second-x, var(--left-wing-second-x)) * 1%) calc(var(--second-y, var(--left-wing-second-y)) * 1%), 
                calc(var(--third-x, var(--left-wing-third-x)) * 1%) calc(var(--third-y, var(--left-wing-third-y)) * 1%)
            );
            will-change: clip-path, transform, -webkit-clip-path;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            -webkit-perspective: 1000;
            perspective: 1000;
            -webkit-transform-style: preserve-3d;
            transform-style: preserve-3d;
        }

        .button .left:after {
            --x: 0;
            --z-index: 1;
            --background: var(--left-body-background);
            --first-x: var(--left-body-first-x);
            --first-y: var(--left-body-first-y);
            --second-x: var(--left-body-second-x);
            --second-y: var(--left-body-second-y);
            --third-x: var(--left-body-third-x);
            --third-y: var(--left-body-third-y);
        }

        .button .right:before {
            --x: -0.4%;
            --z-index: 2;
            --background: var(--right-wing-background);
            --first-x: var(--right-wing-first-x);
            --first-y: var(--right-wing-first-y);
            --second-x: var(--right-wing-second-x);
            --second-y: var(--right-wing-second-y);
            --third-x: var(--right-wing-third-x);
            --third-y: var(--right-wing-third-y);
        }

        .button .right:after {
            --x: 0;
            --z-index: 1;
            --background: var(--right-body-background);
            --first-x: var(--right-body-first-x);
            --first-y: var(--right-body-first-y);
            --second-x: var(--right-body-second-x);
            --second-y: var(--right-body-second-y);
            --third-x: var(--right-body-third-x);
            --third-y: var(--right-body-third-y);
        }

        .button span {
            display: block;
            position: relative;
            z-index: 4;
            opacity: var(--text-opacity);
        }

        .button span.success {
            z-index: 0;
            position: absolute;
            left: 0;
            right: 0;
            top: 8px;
            transform: rotate(calc(var(--rotate) * -1deg)) scale(var(--success-scale)) translateZ(0);
            opacity: var(--success-opacity);
            color: var(--success);
        }

        html {
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        * {
            box-sizing: inherit;
        }

        *:before,
        *:after {
            box-sizing: inherit;
        }

        body {
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Inter', Arial, sans-serif;
            background: #E1E6F9;
            position: relative;
            overflow: hidden;
        }
        
        #three-canvas {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <canvas id="three-canvas"></canvas>
    
    <button class="button">
        <span class="default">Send</span>
        <span class="success">Sent</span>
        <div class="left"></div>
        <div class="right"></div>
    </button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <script>
        
        // Three.js Bird Geometry (MATCH loading animation)
        function Bird() {
            const geometry = new THREE.BufferGeometry();
            
            // Boid bird shape: arrow/triangle pointing forward with symmetric wings
            const vertices = new Float32Array([
                0, 0, 0,      // 0: nose (front point)
                -1, -1, 0,    // 1: bottom left back
                1, -1, 0,     // 2: bottom right back
                -1, 1, 0,     // 3: top left back
                -2, 0, 0,     // 4: left wing tip (will animate - Y coordinate)
                2, 0, 0,      // 5: right wing tip (will animate - Y coordinate)
            ]);
            
            const indices = new Uint16Array([
                0, 1, 2,  // Nose to bottom back
                0, 1, 4,  // Nose to left wing
                0, 2, 5,  // Nose to right wing
                0, 3, 4,  // Nose to top left wing
                0, 3, 5,  // Nose to top right wing
                1, 3, 4,  // Left side
                2, 3, 5,  // Right side
            ]);
            
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.setIndex(new THREE.BufferAttribute(indices, 1));
            geometry.computeVertexNormals();
            
            return geometry;
        }

        // Boid class with physics
        var Boid = function() {
            var vector = new THREE.Vector3();
            var _acceleration;
            var _maxSpeed = 2; // Slower speed
            var _maxSteerForce = 0.05; // Gentler steering

            this.position = new THREE.Vector3();
            this.velocity = new THREE.Vector3();
            _acceleration = new THREE.Vector3();

            this.setGoal = function(target) {
                var steer = new THREE.Vector3();
                steer.subVectors(target, this.position);
                steer.multiplyScalar(0.003); // Slower acceleration
                _acceleration.add(steer);
            }

            this.move = function() {
                this.velocity.add(_acceleration);
                var l = this.velocity.length();
                if (l > _maxSpeed) {
                    this.velocity.divideScalar(l / _maxSpeed);
                }
                this.position.add(this.velocity);
                _acceleration.set(0, 0, 0);
            }
        }

        // Three.js setup
        let scene, camera, renderer, bird, boid;
        let threeJsActive = false;
        let waypoints = [];
        let currentWaypoint = 0;

        function initThreeJS() {
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(
                window.innerWidth / -2, window.innerWidth / 2,
                window.innerHeight / 2, window.innerHeight / -2,
                1, 1000
            );
            camera.position.z = 450;

            renderer = new THREE.WebGLRenderer({ 
                canvas: document.getElementById('three-canvas'),
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);

            const birdGeometry = new Bird();
            const birdMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDDC57A, // Golden tan to match button
                shininess: 20,
                transparent: true,
                opacity: 1.0,
                side: THREE.DoubleSide 
            });
            bird = new THREE.Mesh(birdGeometry, birdMaterial);
            // Scale adjusted for OrthographicCamera - loading uses 1.2 with PerspectiveCamera
            bird.scale.set(3, 3, 3);
            bird.phase = 0;
            bird.visible = false; // Hidden until particles complete
            scene.add(bird);
            
            // Add lights for MeshPhongMaterial
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            boid = new Boid();
        }

        function createLoopWaypoints(startX, startY) {
            const points = [];
            const numPoints = 20;
            const loopRadius = 100;
            
            // Get screen dimensions to ensure bird exits completely
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const exitDistance = Math.max(screenWidth, screenHeight) * 1.5; // 1.5x screen size to ensure complete exit
            
            // CRITICAL: Define safe boundaries to keep bird in viewport (not over header)
            // In OrthographicCamera coordinates: Y=0 is center, positive Y is UP
            // Top edge is at screenHeight/2, but we need margin for header
            const headerHeightPx = 80; // Adjust this based on your header height
            const maxY = (screenHeight / 2) - headerHeightPx; // Stay below header
            const minY = -(screenHeight / 2); // Bottom edge
            
            console.log('Start position:', startX, startY);
            console.log('Screen size:', screenWidth, screenHeight);
            console.log('Y boundaries - Max (stay below header):', maxY, 'Min (bottom):', minY);
            
            // Create path: fly UP (within bounds), loop-de-loop, exit bottom right off screen
            for (let i = 0; i <= numPoints; i++) {
                const t = i / numPoints;
                let x, y;
                
                if (t < 0.3) {
                    // Fly UPWARD - but clamp to maxY to avoid header
                    const t1 = t / 0.3;
                    x = startX + t1 * 80;
                    // Instead of flying fixed 200px up, calculate safe distance
                    const targetY = startY + 200;
                    y = Math.min(targetY * t1 + startY * (1 - t1), maxY - loopRadius); // Stay below maxY with margin
                } else if (t < 0.7) {
                    // Complete the loop-de-loop (clamped to safe area)
                    const t2 = (t - 0.3) / 0.4;
                    const angle = t2 * Math.PI * 2;
                    const loopCenterX = startX + 150;
                    // Clamp loop center to ensure full loop stays below header
                    const desiredLoopY = startY + 200;
                    const loopCenterY = Math.min(desiredLoopY, maxY - loopRadius);
                    x = loopCenterX + Math.sin(angle) * loopRadius;
                    y = loopCenterY - Math.cos(angle) * loopRadius; // This creates the circular loop
                } else {
                    // Exit toward bottom right - fly FAR off screen (no clamping on exit)
                    const t3 = (t - 0.7) / 0.3;
                    x = startX + 250 + t3 * exitDistance;
                    y = startY + 100 - t3 * exitDistance; // Move down and right off screen
                }
                
                if (i < 5 || i > numPoints - 3) console.log('Waypoint', i, ':', x, y, 'maxY:', maxY);
                points.push(new THREE.Vector3(x, y, 0));
            }
            
            return points;
        }

        function animateThreeJS() {
            if (!threeJsActive) return;
            requestAnimationFrame(animateThreeJS);

            // Use boid physics to smoothly move toward next waypoint
            if (currentWaypoint < waypoints.length) {
                const target = waypoints[currentWaypoint];
                boid.setGoal(target);
                boid.move();
                
                bird.position.copy(boid.position);
                
                // Move to next waypoint when close enough
                if (boid.position.distanceTo(target) < 30) {
                    currentWaypoint++;
                }
                
                // Calculate rotation based on velocity
                bird.rotation.y = Math.atan2(-boid.velocity.z, boid.velocity.x);
                bird.rotation.z = Math.asin(boid.velocity.y / boid.velocity.length());
                
                // Wing flapping - Match boid bird animation from loading screen
                if (bird.phase === undefined) bird.phase = 0;
                bird.phase += 0.3; // Consistent increment per frame
                const flapAmount = Math.sin(bird.phase) * 5;
                bird.geometry.attributes.position.array[13] = flapAmount;
                bird.geometry.attributes.position.array[16] = flapAmount;
                bird.geometry.attributes.position.needsUpdate = true;
            } else {
                // Animation complete
                threeJsActive = false;
                const button = document.querySelector('.button');
                setTimeout(() => {
                    button.removeAttribute('style');
                    gsap.fromTo(button, {
                        opacity: 0,
                        y: -8
                    }, {
                        opacity: 1,
                        y: 0,
                        clearProps: true,
                        duration: 0.3,
                        onComplete() {
                            button.classList.remove('active');
                        }
                    });
                }, 500);
            }

            renderer.render(scene, camera);
        }

        initThreeJS();

        // Button animation - fade out and transform into bird
        document.querySelectorAll('.button').forEach(button => {
            button.addEventListener('click', e => {
                if(!button.classList.contains('active')) {
                    // CRITICAL: Lock button position IMMEDIATELY - BEFORE any other changes
                    // Capture position from viewport to prevent any layout shifts
                    const buttonRect = button.getBoundingClientRect();
                    
                    // Lock position SYNCHRONOUSLY with !important - do this FIRST
                    button.style.setProperty('position', 'fixed', 'important');
                    button.style.setProperty('left', `${buttonRect.left}px`, 'important');
                    button.style.setProperty('top', `${buttonRect.top}px`, 'important');
                    button.style.setProperty('width', `${buttonRect.width}px`, 'important');
                    button.style.setProperty('height', `${buttonRect.height}px`, 'important');
                    button.style.setProperty('margin', '0', 'important');
                    button.style.setProperty('padding', '8px 24px', 'important');
                    button.style.setProperty('transform', 'none', 'important');
                    button.style.setProperty('z-index', '999999', 'important');
                    
                    // Force reflow to ensure position is locked
                    void button.offsetWidth;
                    void button.offsetHeight;
                    
                    // Verify position is locked before proceeding
                    const verifyRect = button.getBoundingClientRect();
                    if (verifyRect.left !== buttonRect.left || verifyRect.top !== buttonRect.top) {
                        console.warn('⚠️ Button moved during lock! Re-locking...');
                        button.style.setProperty('left', `${buttonRect.left}px`, 'important');
                        button.style.setProperty('top', `${buttonRect.top}px`, 'important');
                        void button.offsetWidth;
                    }
                    
                    // NOW add active class (after position is locked)
                    button.classList.add('active');

                    // Get button position for Three.js bird (use the locked position)
                    const buttonCenterX = buttonRect.left + buttonRect.width / 2 - window.innerWidth / 2;
                    const buttonCenterY = -(buttonRect.top + buttonRect.height / 2 - window.innerHeight / 2);

                    // Position bird at button location immediately
                    boid.position.set(buttonCenterX, buttonCenterY, 0);
                    bird.position.copy(boid.position);
                    
                    // Start bird at larger initial size so it appears to emerge from button
                    bird.visible = true;
                    bird.scale.set(0.5, 0.5, 0.5); // Start at 50% instead of 10% - more visible transformation
                    
                    // CRITICAL: Ensure button is fully visible before transformation
                    button.style.opacity = '1';
                    button.style.visibility = 'visible';
                    void button.offsetWidth; // Force reflow
                    
                    // CRITICAL: Button transforms directly into bird - no explosion
                    // Button fades out as bird scales up, creating seamless transformation
                    // Start IMMEDIATELY when bird becomes visible
                    const transformationDuration = 1000; // 1000ms for slower, more visible transformation
                    const pauseBeforeFlight = 600; // 600ms pause after bird appears before flight starts
                    
                    // Use GSAP timeline for perfect synchronization (if GSAP is available)
                    if (typeof gsap !== 'undefined') {
                        const tl = gsap.timeline();
                        
                        // Button fades out smoothly - no scaling, just fade
                        tl.to(button, {
                            opacity: 0,
                            duration: transformationDuration / 1000, // Convert to seconds
                            ease: 'power2.out', // Smooth easing for transformation
                            onUpdate: () => {
                                // Re-lock position during transformation
                                button.style.setProperty('left', `${buttonRect.left}px`, 'important');
                                button.style.setProperty('top', `${buttonRect.top}px`, 'important');
                                button.style.setProperty('transform', 'none', 'important'); // No scaling
                            },
                            onComplete: () => {
                                button.style.opacity = '0';
                                button.style.pointerEvents = 'none';
                                button.style.setProperty('transform', 'none', 'important');
                                button.style.setProperty('left', `${buttonRect.left}px`, 'important');
                                button.style.setProperty('top', `${buttonRect.top}px`, 'important');
                                button.style.setProperty('visibility', 'hidden', 'important');
                                button.style.setProperty('display', 'none', 'important');
                                button.classList.remove('active');
                            }
                        }, 0);
                        
                        // Bird scales up at EXACT same time - synchronized transformation
                        const scaleObj = { value: 0.5 }; // Start at 50% (matches initial bird scale)
                        tl.to(scaleObj, {
                            value: 1,
                            duration: transformationDuration / 1000, // Same duration as button fade
                            ease: 'power2.out',
                            onUpdate: () => {
                                const scale = scaleObj.value * 3;
                                bird.scale.set(scale, scale, scale);
                            },
                            onComplete: () => {
                                // Brief pause after bird appears before starting flight
                                setTimeout(() => {
                                    // Start flight animation
                                    boid.velocity.set(0.5, -0.5, 0);
                                    waypoints = createLoopWaypoints(buttonCenterX, buttonCenterY);
                                    currentWaypoint = 0;
                                    threeJsActive = true;
                                    animateThreeJS();
                                }, pauseBeforeFlight); // Brief pause after transformation before flight starts
                            }
                        }, 0);
                        
                        // Start timeline immediately
                        tl.play();
                    } else {
                        // Fallback: Use requestAnimationFrame if GSAP not available
                        let fadeStartTime = null;
                        const fadeStep = (timestamp) => {
                            if (!fadeStartTime) fadeStartTime = timestamp;
                            const elapsed = timestamp - fadeStartTime;
                            const progress = Math.min(elapsed / transformationDuration, 1);
                            const easeOut = 1 - Math.pow(1 - progress, 2); // easeOutQuad for smooth fade
                            
                            // Button fades out smoothly - no scaling
                            const opacity = 1 - easeOut; // Fade from 1.0 to 0.0
                            
                            // Apply fade effect (no scale)
                            button.style.opacity = opacity.toString();
                            button.style.setProperty('transform', 'none', 'important'); // No scaling
                            
                            // Re-lock position during transformation to prevent any movement
                            button.style.setProperty('left', `${buttonRect.left}px`, 'important');
                            button.style.setProperty('top', `${buttonRect.top}px`, 'important');
                            
                            if (progress < 1) {
                                requestAnimationFrame(fadeStep);
                            } else {
                                // Hide button completely after transformation
                                button.style.opacity = '0';
                                button.style.pointerEvents = 'none';
                                button.style.setProperty('transform', 'none', 'important');
                                button.style.setProperty('visibility', 'hidden', 'important');
                                button.style.setProperty('display', 'none', 'important');
                                // Final position lock
                                button.style.setProperty('left', `${buttonRect.left}px`, 'important');
                                button.style.setProperty('top', `${buttonRect.top}px`, 'important');
                                button.classList.remove('active');
                            }
                        };
                        requestAnimationFrame(fadeStep);
                        
                        // Animate bird scaling up at EXACT same time as button transformation
                        const scaleObj = { value: 0.5 }; // Start at 50% (matches initial bird scale)
                        anime({
                            targets: scaleObj,
                            value: 1,
                            duration: transformationDuration, // Same duration as button fade
                            easing: 'easeOutCubic',
                            update: () => {
                                const scale = scaleObj.value * 3;
                                bird.scale.set(scale, scale, scale);
                            },
                            complete: () => {
                                // Brief pause after bird appears before starting flight
                                setTimeout(() => {
                                    // Start flight animation
                                    boid.velocity.set(0.5, -0.5, 0);
                                    waypoints = createLoopWaypoints(buttonCenterX, buttonCenterY);
                                    currentWaypoint = 0;
                                    threeJsActive = true;
                                    animateThreeJS();
                                }, pauseBeforeFlight); // Brief pause after transformation before flight starts
                            }
                        });
                    }
                }
            });
        });

        window.addEventListener('resize', () => {
            camera.left = window.innerWidth / -2;
            camera.right = window.innerWidth / 2;
            camera.top = window.innerHeight / 2;
            camera.bottom = window.innerHeight / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>

